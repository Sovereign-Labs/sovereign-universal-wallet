pub mod display;
#[cfg(feature = "serde")]
pub mod json_to_borsh;
pub mod schema;
pub mod ty;

pub extern crate bech32;

#[cfg(feature = "macros")]
/// Implements the [`SchemaGenerator`](sov_universal_wallet::schema::SchemaGenerator) trait for the
/// annotated struct or enum.
///
/// The schema generated by the trait allows two main features.
/// First, the borsh-encoding of the type to be dispalyed in a human-readable format, with the exact
/// formatting controlled by attributes on the fields of the type.
/// Second, it allows a JSON-encoding of the type to be translated into borsh-encoding, without
/// needing access to the original Rust definition of the type.
///
/// ## Attributes: `#[sov_wallet(bound = "T: Trait")]`
///
/// Tells the proc-macro to add the specified bound to the where clause
/// of the generated implementation instead of adding the default `T: SchemaGenerator` (where `T`
/// is the type of the annotated field).
///
/// This annotation may only be applied to fields, not items.
///
/// ## Attributes: `#[sov_wallet(hidden)]`
///
/// Causes the field to be hidden from the user during display. This is often used for data
/// that can't be displayed in a human-readable format, such as merkle proofs. If the field is not
/// present in the `borsh` serialization of the type, use `#[sov_wallet(skip)]` instead.
///
/// This annotation may only be applied to fields, not items.
///
/// ```rust
/// use sov_universal_wallet::schema::{Schema, safe_string::SafeString};
/// use sov_universal_wallet::UniversalWallet;
///
/// #[derive(UniversalWallet, borsh::BorshSerialize)]
/// pub struct Unreadable {
///    name: SafeString,
///    #[sov_wallet(hidden)]
///    opaque_contents: Vec<u8>,
/// }
/// let serialized = borsh::to_vec(&Unreadable { name: "foo.txt".try_into().unwrap(), opaque_contents: vec![23, 74, 119, 119, 2, 232, 22]}).unwrap();
/// assert_eq!(Schema::of_single_type::<Unreadable>().unwrap().display(0, &serialized).unwrap(), r#"{ name: "foo.txt" }"#);
/// ```
/// Notice also the use of the `SafeString` type here - this is to ensure the string can be safely
/// displayed to the user. By default, unconstrained Strings are forbidden in schemas; for blobs of
/// data, use byte arrays/vectors directly. If a String is absolutely required, a newtype wrapper
/// can be used.
///
/// ## Attributes: `#[sov_wallet(as_ty = "path::to::Type")]`
///
/// Inserts the schema of the specified type in place of the schema for the annotated field. Note that the subsituted type
/// must have exactly the same borsh serialization as the original.
///
/// This is useful when you want to display a foreign type that doesn't implement [`SchemaGenerator`](sov_universal_wallet::schema::SchemaGenerator),
/// or when you want to override the default schema for a type in a particular context.
///
/// ```rust
/// use sov_universal_wallet::{schema::Schema, UniversalWallet};
///
/// // A foreign type that doesn't derive UniversalWallet
/// #[derive(borsh::BorshSerialize)]
/// pub struct Foreign(u64);
///
/// #[derive(UniversalWallet, borsh::BorshSerialize)]
/// pub struct Tagged {
///    #[sov_wallet(as_ty = "u64")]
///    data: Foreign,
///    tag: i8,
/// }
/// let serialized = borsh::to_vec(&Tagged { data: Foreign(300_000), tag: -5 }).unwrap();
/// assert_eq!(Schema::of_single_type::<Tagged>().unwrap().display(0, &serialized).unwrap(), r#"{ data: 300000, tag: -5 }"#);
/// ```
///
/// ## Attributes: `#[sov_wallet(fixed_point({decimals}))]`
///
/// Specifies fixed-point formatting for an integer field. The decimals can be specified in one
/// of the following ways:
///  - `fixed_point(n)` where `n` is an integer literal, e.g. `fixed_point(18)`
///  - `fixed_point(from_field({n}))` or `fixed_point(from_field(n, offset=m))` where `n` and
///    `m` are integer literals: this causes the formatting to refer to the `nth` field within
///    the same parent structure (struct or tuple), by index, and read a single byte at the
///    given offset `m`. The offset defaults to `0` if not specified.
///
/// ```rust
/// use sov_universal_wallet::{schema::Schema, UniversalWallet};
/// #[derive(UniversalWallet, borsh::BorshSerialize)]
/// pub struct Coins {
///     #[sov_wallet(fixed_point(from_field(1)))]
///     amount: u128,
///     #[sov_wallet(hidden)]
///     decimals: u8
/// }
/// let serialized = borsh::to_vec(&Coins { amount: 475200, decimals: 3 }).unwrap();
/// assert_eq!(Schema::of_single_type::<Coins>().unwrap().display(0, &serialized).unwrap(), r#"{ amount: 475.2 }"#);
/// ```
///
/// **Security note**: uniquely, this formats the display using user-submitted input. If the
/// accuracy of the displayed string is important for security, it is crucial that the submitted
/// value for the amount of decimals be treated as the source of truth, as that will be what the
/// user will have been presented with.
/// For example, when using the schema to sign on-chain messages referencing cryptocurrency
/// amounts, any message where the decimals field does not match the currency's canonical decimal
/// count **must** be considered invalid and rejected.
///
/// ## Attributes: `#[sov_wallet(template({template spec}))]`
///
/// Annotates the field for inclusion in a standard template.
///
/// Templates specify several input bindings that can be later provided to the schema (by
/// name), and the schema will fill the inputs with the correct encoding to output a fully
/// encoded target type. In this context, the target can be any of the schema root types.
///
/// Fields can be annotated with either an input binding or a pre-defined value (which will be
/// hardcoded into the template).
///
/// The contents of the template attribute are of the format
/// ```ignore
/// template("template_one" = {field data}, "template_two" = {metadata}, ...)
/// ```
/// Where templates are defined (and distinguished) by their string name. The field data, in
/// turn, is one of either
/// * `input` for an input binding on the field name,
/// * `input("name")` for an input binding with an arbitrary name, or
/// * `value("data")` for a pre-defined hardcoded value, or
/// * `value(bytes = "data")` for byte fields, reusing the field's `sov_wallet(display)`
///   attribute for parsing; or
/// * `value(default)` to use the type's `std::default::Default::default()` value in the
///   template.
///
/// Note that input names must be unique throughout a single template. For example, it's not
/// possible to annotate two identically-named fields (in different structs) with `input` and
/// have them be part of the same template; and it is not possible to pass the same string
/// twice as part of `input("name")` within the same template.
///
/// If a type definition annotates template attributes on one of its fields, all of its fields
/// must have template metadata. Complex types that have their own subfields can be annotated
/// at a lower level, and a field of such a type will be considered correctly annotated for the
/// template when used in parent types.
///
/// **Enum annotation:**
/// As a special rule, in an enum, a template can only be defined on the fields of a single
/// variant. It is an error to have template attributes with the same name available from
/// multiple variants.
///
/// To prevent unexpected/undesired inheriting of templates causing an error as per above, enum
/// variants must be annotated with the following syntax:
/// ```ignore
/// template("template_name", ...)
/// ```
/// I.e. specifying a list of names, with no extra data necessary. Only templates explicitly
/// named in the variant's own attribute will be available on that attribute.
///
/// ```rust
/// use sov_universal_wallet::schema::Schema;
/// use sov_universal_wallet::schema::safe_string::SafeString;
/// use sov_universal_wallet::UniversalWallet;
/// #[derive(UniversalWallet, borsh::BorshSerialize)]
/// pub enum CallMessage {
///     #[sov_wallet(template("transfer"))]
///     Transfer {
///         #[sov_wallet(template("transfer" = input("to")))]
///         to: SafeString,
///         coins: Coins,
///     }
/// }
/// #[derive(UniversalWallet, borsh::BorshSerialize)]
/// pub struct Coins {
///     #[sov_wallet(template("transfer" = input("amount")))]
///     pub amount: u128,
///     #[sov_wallet(template("transfer" = value("MY_TOKEN_ID")))]
///     pub token_id: SafeString,
/// }
///
/// let schema = Schema::of_single_type::<CallMessage>().unwrap();
/// let encoded_call = schema.fill_template_from_json(0, "transfer", r#"{ "to":
/// "sov1234_whatever_address", "amount": 2000 }"#).unwrap();
///
/// assert_eq!(schema.display(0, &encoded_call).unwrap(), r#"Transfer { to: "sov1234_whatever_address", coins: { amount: 2000, token_id: "MY_TOKEN_ID" } }"#);
/// ```
///
/// ## Attributes: `#[sov_wallet(template_inherit)]`
/// Applies to enums only. _Overrides_ the default behaviour, described above, which normally
/// makes templates opt-in for enum variants. When `template_inherit` is specified on an enum,
/// instead, every enum variant will automatically inherit all templates available on the type
/// of that variant.
///
/// ## Attributes: `#[sov_wallet(template_override_ty = "RemoteType")]`
///
/// Sets the named type to be the source of inherited template definitions, rather than the
/// actual field's type. This is useful when importing crates, such as sov module
/// implementations, that define their own `#[sov_wallet(template(...))]` attributes on their
/// types that are not relevant for the rollup.
///
/// * An easy way to disable any inherited templates from a field's type is to set
///   `#[sov_wallet(template_override_ty = "()")]`.
///
/// * To actually replace the templates with your own, build a set of scaffold types that
///   mirror the structure of the original, provide the desired `#[sov_wallet(template(...))]`
///   attributes and #[derive(UniversalWallet)] on the type; then it can be used as the argument
///   to `template_override_ty`.
///
/// ```rust
/// use sov_universal_wallet::{schema::Schema, UniversalWallet};
///
/// /// A foreign module
/// mod foreign {
///     use sov_universal_wallet::UniversalWallet;
///     #[derive(UniversalWallet, borsh::BorshSerialize)]
///     pub struct ForeignData {
///         #[sov_wallet(template("call" = input("hello_world")))]
///         data: u64,
///     }
/// }
///
/// #[derive(UniversalWallet, borsh::BorshSerialize)]
/// pub struct SurrogateDataStruct {
///     #[sov_wallet(template("call" = input("my_data")))]
///     data: u64,
/// }
///
/// #[derive(UniversalWallet, borsh::BorshSerialize)]
/// pub struct CallMessage {
///    #[sov_wallet(template_override_ty = "SurrogateDataStruct")]
///    data: foreign::ForeignData,
///    #[sov_wallet(template("call" = input("extra_data")))]
///    extra_data: u8,
/// }
///
/// let schema = Schema::of_single_type::<CallMessage>().unwrap();
/// let encoded_call = schema.fill_template_from_json(
///     0,
///     "call",
///     r#"{ "my_data": 12, "extra_data": 8 }"#
/// ).unwrap();
///
/// assert_eq!(schema.display(0, &encoded_call).unwrap(), r#"{ data: { data: 12 }, extra_data: 8 }"#);
///
/// // Without using template_override_ty, the template would've looked like this:
/// // let encoded_call = schema.fill_template_from_json(
/// //    0,
/// //    "call",
/// //    r#"{ "foreign_data": 12, "extra_data": 8 }"#
/// // ).unwrap();
///
/// ```
///
/// ## Attributes: `#[sov_wallet(skip)]`
///
/// Causes the field to be excluded from the Schema entirely. This should be used if the field is not present in
/// the `borsh` serialization of the type. If the type is present in the serialization but should not be displayed,
/// use `#[sov_wallet(hidden)]` instead.
///
/// ```rust
/// use sov_universal_wallet::schema::Schema;
/// use sov_universal_wallet::UniversalWallet;
/// #[derive(UniversalWallet, borsh::BorshSerialize)]
/// pub struct File {
///     #[borsh(skip)]
///     #[sov_wallet(skip)]
///     checksum: Option<[u8;32]>,
///     contents: Vec<u8>,
/// }
/// let serialized = borsh::to_vec(&File { contents: vec![1, 2, 3], checksum: None }).unwrap();
/// assert_eq!(Schema::of_single_type::<File>().unwrap().display(0, &serialized).unwrap(), r#"{ contents: 0x010203 }"#);
/// ```
///
/// /// ## Attributes: `#[sov_wallet(hide_tag)]`
///
/// Causes the tag of an enum to be skipped when displaying from its human-readable representation.
///
/// ```rust
/// use sov_universal_wallet::schema::Schema;
/// use sov_universal_wallet::UniversalWallet;
/// #[derive(UniversalWallet, borsh::BorshSerialize)]
/// #[sov_wallet(hide_tag)]
/// pub enum Example {
///     Hash([u8;32]),
///     Value(u64)
/// }
/// let serialized = borsh::to_vec(&Example::Value(1)).unwrap();
/// assert_eq!(Schema::of_single_type::<Example>().unwrap().display(0, &serialized).unwrap(), "1");
/// ```
///
/// ## Attributes: `#[sov_wallet(display({encoding}))]`
///
/// Specifies the encoding to use when displaying a byte sequence. The encoding can be one of the following:
/// - `hex`: displays the type as a hexadecimal string with the prefix "0x"
/// - `decimal`: displays the type as a list of decimal numbers in square brackets
/// - `bech32(prefix = "my_prefix_expr")`: displays the type as a bech32-encoded string with the specified human-readable part.
/// - `bech32m(prefix = "my_prefix_expr")`: displays the type as a bech32m-encoded string with the specified human-readable part.
///
/// This annotation may only be applied to fields, not items. The field must have type `[u8;N]` or `Vec<u8>` to use this attribute.
///
/// ```rust
/// use sov_universal_wallet::schema::Schema;
/// use sov_universal_wallet::UniversalWallet;
///
/// fn prefix() -> &'static str {
///   "celestia"
/// }
///
/// #[derive(UniversalWallet, borsh::BorshSerialize)]
/// pub struct CelestiaAddress(
///   #[sov_wallet(display(bech32(prefix = "prefix()")))]
///   [u8;32],
/// );
/// let serialized = borsh::to_vec(&CelestiaAddress([1; 32])).unwrap();
/// assert_eq!(Schema::of_single_type::<CelestiaAddress>().unwrap().display(0, &serialized).unwrap(), "celestia1qyqszqgpqyqszqgpqyqszqgpqyqszqgpqyqszqgpqyqszqgpqyqsagv2r7");
/// ```
pub use sov_universal_wallet_macros::UniversalWallet;
